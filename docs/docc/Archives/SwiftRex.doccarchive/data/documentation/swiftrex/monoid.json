{"primaryContentSections":[{"kind":"declarations","declarations":[{"tokens":[{"kind":"keyword","text":"protocol"},{"kind":"text","text":" "},{"kind":"identifier","text":"Monoid"},{"kind":"text","text":" : "},{"kind":"typeIdentifier","identifier":"doc:\/\/SwiftRex\/documentation\/SwiftRex\/Semigroup","preciseIdentifier":"s:8SwiftRex9SemigroupP","text":"Semigroup"}],"languages":["swift"],"platforms":["iOS"]}]},{"kind":"content","content":[{"anchor":"overview","level":2,"type":"heading","text":"Overview"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Axioms:"}]},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Totality"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Associativity"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Identity"}]}]}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"For example, having a "},{"type":"codeVoice","code":"f(x) -> x"},{"type":"text","text":" and a "},{"type":"codeVoice","code":"g(x) -> x"},{"type":"text","text":", one would be able to compose "},{"type":"codeVoice","code":"h = f <> g"},{"type":"text","text":" in a way that the new"},{"type":"text","text":" "},{"type":"text","text":"function "},{"type":"codeVoice","code":"h(x)"},{"type":"text","text":" will be similar to "},{"type":"codeVoice","code":"g(f(x))"},{"type":"text","text":", and there should be a function "},{"type":"codeVoice","code":"i(x)"},{"type":"text","text":" where "},{"type":"codeVoice","code":"i"},{"type":"text","text":", when composed to any"},{"type":"text","text":" "},{"type":"text","text":"other function, will not change the result: "},{"type":"codeVoice","code":"f <> i = i <> f = f"},{"type":"text","text":", for "},{"type":"codeVoice","code":"f"},{"type":"text","text":", "},{"type":"codeVoice","code":"g"},{"type":"text","text":", "},{"type":"codeVoice","code":"h"},{"type":"text","text":" and all other endo-functions."}]}]}],"schemaVersion":{"major":0,"minor":1,"patch":0},"sections":[],"variants":[{"paths":["\/documentation\/swiftrex\/monoid"],"traits":[{"interfaceLanguage":"swift"}]}],"relationshipsSections":[{"identifiers":["doc:\/\/SwiftRex\/documentation\/SwiftRex\/Semigroup"],"kind":"relationships","title":"Inherits From","type":"inheritsFrom"},{"identifiers":["doc:\/\/SwiftRex\/documentation\/SwiftRex\/AfterReducer","doc:\/\/SwiftRex\/documentation\/SwiftRex\/ComposedMiddleware","doc:\/\/SwiftRex\/documentation\/SwiftRex\/IO","doc:\/\/SwiftRex\/documentation\/SwiftRex\/MiddlewareReader","doc:\/\/SwiftRex\/documentation\/SwiftRex\/Reducer"],"kind":"relationships","title":"Conforming Types","type":"conformingTypes"}],"identifier":{"url":"doc:\/\/SwiftRex\/documentation\/SwiftRex\/Monoid","interfaceLanguage":"swift"},"abstract":[{"type":"text","text":"Protocol for a monoid algebra, allowing monoidal composition. It’s a "},{"type":"codeVoice","code":"Semigroup"},{"type":"text","text":" with identity element, element which,"},{"type":"text","text":" "},{"type":"text","text":"when combined to any other element, will keep the other elemenet unchanged, regardless if the composition happened from"},{"type":"text","text":" "},{"type":"text","text":"the left or from the right, for example: "},{"type":"codeVoice","code":"a <> identity = identity <> a = a"},{"type":"text","text":", for any "},{"type":"codeVoice","code":"a"},{"type":"text","text":" in "},{"type":"codeVoice","code":"A"},{"type":"text","text":"."}],"kind":"symbol","metadata":{"fragments":[{"kind":"keyword","text":"protocol"},{"kind":"text","text":" "},{"kind":"identifier","text":"Monoid"}],"title":"Monoid","roleHeading":"Protocol","role":"symbol","symbolKind":"protocol","externalID":"s:8SwiftRex6MonoidP","modules":[{"name":"SwiftRex"}],"navigatorTitle":[{"kind":"identifier","text":"Monoid"}]},"hierarchy":{"paths":[["doc:\/\/SwiftRex\/documentation\/SwiftRex"]]},"topicSections":[{"title":"Type Properties","identifiers":["doc:\/\/SwiftRex\/documentation\/SwiftRex\/Monoid\/identity"]}],"references":{"doc://SwiftRex/documentation/SwiftRex/Monoid/identity":{"role":"symbol","title":"identity","fragments":[{"kind":"keyword","text":"static"},{"kind":"text","text":" "},{"kind":"keyword","text":"var"},{"kind":"text","text":" "},{"kind":"identifier","text":"identity"},{"kind":"text","text":": "},{"kind":"typeIdentifier","text":"Self"}],"abstract":[{"type":"text","text":"Neutral monoidal container. Composing any monoid with an identity monoid should result in a function unchanged, regardless if the empty element is on the left-hand side or the right-hand side."}],"identifier":"doc:\/\/SwiftRex\/documentation\/SwiftRex\/Monoid\/identity","kind":"symbol","required":true,"type":"topic","url":"\/documentation\/swiftrex\/monoid\/identity"},"doc://SwiftRex/documentation/SwiftRex":{"role":"collection","title":"SwiftRex","abstract":[],"identifier":"doc:\/\/SwiftRex\/documentation\/SwiftRex","kind":"symbol","type":"topic","url":"\/documentation\/swiftrex"},"doc://SwiftRex/documentation/SwiftRex/Semigroup":{"role":"symbol","title":"Semigroup","fragments":[{"kind":"keyword","text":"protocol"},{"kind":"text","text":" "},{"kind":"identifier","text":"Semigroup"}],"abstract":[{"type":"text","text":"Protocol for a semigroup, any algebraic structure that allows two of its elements to be combined into one,"},{"type":"text","text":" "},{"type":"codeVoice","code":"(A, A) -> A"},{"type":"text","text":", for any of its elements and keeping associativity property for all the cases, for example:"},{"type":"text","text":" "},{"type":"codeVoice","code":"(a1 <> a2) <> a3 = a1 <> (a2 <> a3)"},{"type":"text","text":" for any "},{"type":"codeVoice","code":"a"},{"type":"text","text":"s in "},{"type":"codeVoice","code":"A"},{"type":"text","text":"."}],"identifier":"doc:\/\/SwiftRex\/documentation\/SwiftRex\/Semigroup","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"Semigroup"}],"url":"\/documentation\/swiftrex\/semigroup"},"doc://SwiftRex/documentation/SwiftRex/AfterReducer":{"deprecated":true,"role":"symbol","title":"AfterReducer","fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"AfterReducer"}],"abstract":[{"type":"text","text":"Wraps a closure that will be called after the Reducer pipeline has changed the state with the current action."},{"type":"text","text":" "},{"type":"text","text":"With this structure, a middleware can schedule some callback to be executed with the new state, and evidently access this state to check what’s"},{"type":"text","text":" "},{"type":"text","text":"different. This can be very useful for Middlewares that perform logging, monitoring or telemetry, so you can check the state before and after"},{"type":"text","text":" "},{"type":"text","text":"reducers’ execution, or how much time it took for the whole chain to be called (in case this middleware is the first in the chain, of course)."},{"type":"text","text":" "},{"type":"codeVoice","code":"AfterReducer"},{"type":"text","text":" is a monoid, that means it can be combined with another "},{"type":"codeVoice","code":"AfterReducer"},{"type":"text","text":" to form a new one (that executes both operations in the"},{"type":"text","text":" "},{"type":"text","text":"reverse order) and an identity instance, that when combined with any other "},{"type":"codeVoice","code":"AfterReducer"},{"type":"text","text":" changes nothing in the result, acting as a neutral"},{"type":"text","text":" "},{"type":"text","text":"element in composition. The identity of an "},{"type":"codeVoice","code":"AfterReducer"},{"type":"text","text":" is the static instance "},{"type":"codeVoice","code":"doNothing()"},{"type":"text","text":", that contains an empty closure for no-op."},{"type":"text","text":" "},{"type":"text","text":"The combination between two "},{"type":"codeVoice","code":"AfterReducer"},{"type":"text","text":" instances occur in reverse order so the first middleware will have its “after reducer” closure executed"},{"type":"text","text":" "},{"type":"text","text":"last. This composition can be achieved by using the operator "},{"type":"codeVoice","code":"<>"}],"identifier":"doc:\/\/SwiftRex\/documentation\/SwiftRex\/AfterReducer","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"AfterReducer"}],"url":"\/documentation\/swiftrex\/afterreducer"},"doc://SwiftRex/documentation/SwiftRex/Monoid":{"role":"symbol","title":"Monoid","fragments":[{"kind":"keyword","text":"protocol"},{"kind":"text","text":" "},{"kind":"identifier","text":"Monoid"}],"abstract":[{"type":"text","text":"Protocol for a monoid algebra, allowing monoidal composition. It’s a "},{"type":"codeVoice","code":"Semigroup"},{"type":"text","text":" with identity element, element which,"},{"type":"text","text":" "},{"type":"text","text":"when combined to any other element, will keep the other elemenet unchanged, regardless if the composition happened from"},{"type":"text","text":" "},{"type":"text","text":"the left or from the right, for example: "},{"type":"codeVoice","code":"a <> identity = identity <> a = a"},{"type":"text","text":", for any "},{"type":"codeVoice","code":"a"},{"type":"text","text":" in "},{"type":"codeVoice","code":"A"},{"type":"text","text":"."}],"identifier":"doc:\/\/SwiftRex\/documentation\/SwiftRex\/Monoid","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"Monoid"}],"url":"\/documentation\/swiftrex\/monoid"},"doc://SwiftRex/documentation/SwiftRex/IO":{"role":"symbol","title":"IO","fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"IO"}],"abstract":[],"identifier":"doc:\/\/SwiftRex\/documentation\/SwiftRex\/IO","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"IO"}],"url":"\/documentation\/swiftrex\/io"},"doc://SwiftRex/documentation/SwiftRex/ComposedMiddleware":{"role":"symbol","title":"ComposedMiddleware","fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"ComposedMiddleware"}],"abstract":[{"type":"text","text":"The "},{"type":"codeVoice","code":"ComposedMiddleware"},{"type":"text","text":" is a container of inner middlewares that are chained together in the order as they were composed. Whenever an "},{"type":"codeVoice","code":"EventProtocol"},{"type":"text","text":" or an "},{"type":"codeVoice","code":"ActionProtocol"},{"type":"text","text":" arrives to be handled by this "},{"type":"codeVoice","code":"ComposedMiddleware"},{"type":"text","text":", it will delegate to its internal chain of middlewares."}],"identifier":"doc:\/\/SwiftRex\/documentation\/SwiftRex\/ComposedMiddleware","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"ComposedMiddleware"}],"url":"\/documentation\/swiftrex\/composedmiddleware"},"doc://SwiftRex/documentation/SwiftRex/MiddlewareReader":{"conformance":{"constraints":[{"type":"codeVoice","code":"MiddlewareType"},{"type":"text","text":" conforms to "},{"type":"codeVoice","code":"MiddlewareProtocol"},{"type":"text","text":" and "},{"type":"codeVoice","code":"Monoid"},{"type":"text","text":"."}],"availabilityPrefix":[{"type":"text","text":"Available when"}],"conformancePrefix":[{"type":"text","text":"Conforms when"}]},"role":"symbol","title":"MiddlewareReader","fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"MiddlewareReader"}],"abstract":[{"type":"text","text":"A MiddlewareReader is a way to lazily inject dependencies into a Middleware. For example, you may want to compose multiple middlewares but from"},{"type":"text","text":" "},{"type":"text","text":"a library, and in this library you don’t have the dependencies to inject just yet, because these dependencies are only present in the main target."},{"type":"text","text":" "},{"type":"text","text":"That way, instead of creating the middlewares (which would require all the dependencies), you can wrap their initializers in a MiddlewareReader."},{"type":"text","text":" "},{"type":"text","text":"The middleware reader is not a middleware, is a a factory (in OOP terms) from "},{"type":"codeVoice","code":"(Dependencies) -> MiddlewareType"},{"type":"text","text":" (in FP approach). The benefit"},{"type":"text","text":" "},{"type":"text","text":"of wrapping the middleware initializers in a MiddlewareReader is that, for all means, MiddlewareReaders can be composed as Middlewares, can be"},{"type":"text","text":" "},{"type":"text","text":"lifted as Middlewares, but all of this without in fact creating the Middlewares."},{"type":"text","text":" "},{"type":"text","text":"Your library can then expose a single MiddlewareReader as public, and you keep all its middlewares as internal classes. From the main target you"},{"type":"text","text":" "},{"type":"text","text":"compose this MiddlewareReader with other MiddlewareReaders coming from other libraries and from the main target itself. Somewhere where you create"},{"type":"text","text":" "},{"type":"text","text":"the Store, you finally inject the dependencies at once and you materialize all your middlewares at the same time."},{"type":"text","text":" "},{"type":"text","text":"Remember that “inject then compose” is the same as “compose then inject”, but while the former needs dependencies upfront, the latter is more"},{"type":"text","text":" "},{"type":"text","text":"flexible for being lazy."},{"type":"text","text":" "},{"type":"text","text":"For those familiar with Functional Programming, this is similar to Reader Monad, but as SwiftRex recommends dependencies only on Middlewares,"},{"type":"text","text":" "},{"type":"text","text":"this Reader works specifically with Middlewares."}],"identifier":"doc:\/\/SwiftRex\/documentation\/SwiftRex\/MiddlewareReader","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"MiddlewareReader"}],"url":"\/documentation\/swiftrex\/middlewarereader"},"doc://SwiftRex/documentation/SwiftRex/Reducer":{"role":"symbol","title":"Reducer","fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"Reducer"}],"abstract":[{"type":"codeVoice","code":"Reducer"},{"type":"text","text":" is a pure function wrapped in a monoid container, that takes an action and the current state to calculate the new state."}],"identifier":"doc:\/\/SwiftRex\/documentation\/SwiftRex\/Reducer","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"Reducer"}],"url":"\/documentation\/swiftrex\/reducer"}}}