{"schemaVersion":{"major":0,"minor":1,"patch":0},"metadata":{"navigatorTitle":[{"kind":"identifier","text":"AfterReducer"}],"role":"symbol","title":"AfterReducer","roleHeading":"Structure","fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"AfterReducer"}],"symbolKind":"struct","externalID":"s:8SwiftRex12AfterReducerV","modules":[{"name":"SwiftRex"}],"platforms":[]},"deprecationSummary":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Use `MiddlewareProtocol` instead of `Middleware`. It doesn't use `AfterReducer`. This struct will be removed on 1.0."}]}],"abstract":[{"type":"text","text":"Wraps a closure that will be called after the Reducer pipeline has changed the state with the current action."},{"type":"text","text":" "},{"type":"text","text":"With this structure, a middleware can schedule some callback to be executed with the new state, and evidently access this state to check what’s"},{"type":"text","text":" "},{"type":"text","text":"different. This can be very useful for Middlewares that perform logging, monitoring or telemetry, so you can check the state before and after"},{"type":"text","text":" "},{"type":"text","text":"reducers’ execution, or how much time it took for the whole chain to be called (in case this middleware is the first in the chain, of course)."},{"type":"text","text":" "},{"type":"codeVoice","code":"AfterReducer"},{"type":"text","text":" is a monoid, that means it can be combined with another "},{"type":"codeVoice","code":"AfterReducer"},{"type":"text","text":" to form a new one (that executes both operations in the"},{"type":"text","text":" "},{"type":"text","text":"reverse order) and an identity instance, that when combined with any other "},{"type":"codeVoice","code":"AfterReducer"},{"type":"text","text":" changes nothing in the result, acting as a neutral"},{"type":"text","text":" "},{"type":"text","text":"element in composition. The identity of an "},{"type":"codeVoice","code":"AfterReducer"},{"type":"text","text":" is the static instance "},{"type":"codeVoice","code":"doNothing()"},{"type":"text","text":", that contains an empty closure for no-op."},{"type":"text","text":" "},{"type":"text","text":"The combination between two "},{"type":"codeVoice","code":"AfterReducer"},{"type":"text","text":" instances occur in reverse order so the first middleware will have its “after reducer” closure executed"},{"type":"text","text":" "},{"type":"text","text":"last. This composition can be achieved by using the operator "},{"type":"codeVoice","code":"<>"}],"sections":[],"identifier":{"url":"doc:\/\/SwiftRex\/documentation\/SwiftRex\/AfterReducer","interfaceLanguage":"swift"},"relationshipsSections":[{"identifiers":["doc:\/\/SwiftRex\/documentation\/SwiftRex\/Monoid","doc:\/\/SwiftRex\/documentation\/SwiftRex\/Semigroup"],"kind":"relationships","title":"Conforms To","type":"conformsTo"}],"hierarchy":{"paths":[["doc:\/\/SwiftRex\/documentation\/SwiftRex"]]},"topicSections":[{"title":"Instance Methods","identifiers":["doc:\/\/SwiftRex\/documentation\/SwiftRex\/AfterReducer\/performBlock()"]},{"title":"Type Properties","identifiers":["doc:\/\/SwiftRex\/documentation\/SwiftRex\/AfterReducer\/identity"]},{"title":"Type Methods","identifiers":["doc:\/\/SwiftRex\/documentation\/SwiftRex\/AfterReducer\/do(_:)","doc:\/\/SwiftRex\/documentation\/SwiftRex\/AfterReducer\/doNothing()"]}],"variants":[{"paths":["\/documentation\/swiftrex\/afterreducer"],"traits":[{"interfaceLanguage":"swift"}]}],"kind":"symbol","primaryContentSections":[{"kind":"declarations","declarations":[{"tokens":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"AfterReducer"}],"languages":["swift"],"platforms":["iOS"]}]}],"references":{"doc://SwiftRex/documentation/SwiftRex/AfterReducer/do(_:)":{"role":"symbol","title":"do(_:)","fragments":[{"kind":"keyword","text":"static"},{"kind":"text","text":" "},{"kind":"keyword","text":"func"},{"kind":"text","text":" "},{"kind":"identifier","text":"`do`"},{"kind":"text","text":"(() -> "},{"kind":"typeIdentifier","text":"Void","preciseIdentifier":"s:s4Voida"},{"kind":"text","text":") -> "},{"kind":"typeIdentifier","text":"AfterReducer","preciseIdentifier":"s:8SwiftRex12AfterReducerV"}],"abstract":[{"type":"text","text":"Schedules some task to be executed right after Reducer chain has finished and new state is published"}],"identifier":"doc:\/\/SwiftRex\/documentation\/SwiftRex\/AfterReducer\/do(_:)","kind":"symbol","type":"topic","deprecated":true,"url":"\/documentation\/swiftrex\/afterreducer\/do(_:)"},"doc://SwiftRex/documentation/SwiftRex/AfterReducer/doNothing()":{"role":"symbol","title":"doNothing()","fragments":[{"kind":"keyword","text":"static"},{"kind":"text","text":" "},{"kind":"keyword","text":"func"},{"kind":"text","text":" "},{"kind":"identifier","text":"doNothing"},{"kind":"text","text":"() -> "},{"kind":"typeIdentifier","text":"AfterReducer","preciseIdentifier":"s:8SwiftRex12AfterReducerV"}],"abstract":[{"type":"text","text":"The identity of an "},{"type":"codeVoice","code":"AfterReducer"},{"type":"text","text":" is the static instance "},{"type":"codeVoice","code":"doNothing()"},{"type":"text","text":", that contains an empty closure for no-op."},{"type":"text","text":" "},{"type":"text","text":"When combined with any other "},{"type":"codeVoice","code":"AfterReducer"},{"type":"text","text":" changes nothing in the result, acting as a neutral element in composition."}],"identifier":"doc:\/\/SwiftRex\/documentation\/SwiftRex\/AfterReducer\/doNothing()","kind":"symbol","type":"topic","deprecated":true,"url":"\/documentation\/swiftrex\/afterreducer\/donothing()"},"doc://SwiftRex/documentation/SwiftRex/AfterReducer":{"deprecated":true,"role":"symbol","title":"AfterReducer","fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"AfterReducer"}],"abstract":[{"type":"text","text":"Wraps a closure that will be called after the Reducer pipeline has changed the state with the current action."},{"type":"text","text":" "},{"type":"text","text":"With this structure, a middleware can schedule some callback to be executed with the new state, and evidently access this state to check what’s"},{"type":"text","text":" "},{"type":"text","text":"different. This can be very useful for Middlewares that perform logging, monitoring or telemetry, so you can check the state before and after"},{"type":"text","text":" "},{"type":"text","text":"reducers’ execution, or how much time it took for the whole chain to be called (in case this middleware is the first in the chain, of course)."},{"type":"text","text":" "},{"type":"codeVoice","code":"AfterReducer"},{"type":"text","text":" is a monoid, that means it can be combined with another "},{"type":"codeVoice","code":"AfterReducer"},{"type":"text","text":" to form a new one (that executes both operations in the"},{"type":"text","text":" "},{"type":"text","text":"reverse order) and an identity instance, that when combined with any other "},{"type":"codeVoice","code":"AfterReducer"},{"type":"text","text":" changes nothing in the result, acting as a neutral"},{"type":"text","text":" "},{"type":"text","text":"element in composition. The identity of an "},{"type":"codeVoice","code":"AfterReducer"},{"type":"text","text":" is the static instance "},{"type":"codeVoice","code":"doNothing()"},{"type":"text","text":", that contains an empty closure for no-op."},{"type":"text","text":" "},{"type":"text","text":"The combination between two "},{"type":"codeVoice","code":"AfterReducer"},{"type":"text","text":" instances occur in reverse order so the first middleware will have its “after reducer” closure executed"},{"type":"text","text":" "},{"type":"text","text":"last. This composition can be achieved by using the operator "},{"type":"codeVoice","code":"<>"}],"identifier":"doc:\/\/SwiftRex\/documentation\/SwiftRex\/AfterReducer","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"AfterReducer"}],"url":"\/documentation\/swiftrex\/afterreducer"},"doc://SwiftRex/documentation/SwiftRex/AfterReducer/identity":{"role":"symbol","title":"identity","fragments":[{"kind":"keyword","text":"static"},{"kind":"text","text":" "},{"kind":"keyword","text":"let"},{"kind":"text","text":" "},{"kind":"identifier","text":"identity"},{"kind":"text","text":": "},{"kind":"typeIdentifier","text":"AfterReducer","preciseIdentifier":"s:8SwiftRex12AfterReducerV"}],"abstract":[{"type":"text","text":"The identity of an "},{"type":"codeVoice","code":"AfterReducer"},{"type":"text","text":" is the static instance "},{"type":"codeVoice","code":"doNothing()"},{"type":"text","text":", that contains an empty closure for no-op."},{"type":"text","text":" "},{"type":"text","text":"When combined with any other "},{"type":"codeVoice","code":"AfterReducer"},{"type":"text","text":" changes nothing in the result, acting as a neutral element in composition."}],"identifier":"doc:\/\/SwiftRex\/documentation\/SwiftRex\/AfterReducer\/identity","kind":"symbol","type":"topic","deprecated":true,"url":"\/documentation\/swiftrex\/afterreducer\/identity"},"doc://SwiftRex/documentation/SwiftRex/AfterReducer/performBlock()":{"role":"symbol","title":"performBlock()","fragments":[{"kind":"keyword","text":"func"},{"kind":"text","text":" "},{"kind":"identifier","text":"performBlock"},{"kind":"text","text":"()"}],"abstract":[],"identifier":"doc:\/\/SwiftRex\/documentation\/SwiftRex\/AfterReducer\/performBlock()","kind":"symbol","type":"topic","deprecated":true,"url":"\/documentation\/swiftrex\/afterreducer\/performblock()"},"doc://SwiftRex/documentation/SwiftRex/Monoid":{"role":"symbol","title":"Monoid","fragments":[{"kind":"keyword","text":"protocol"},{"kind":"text","text":" "},{"kind":"identifier","text":"Monoid"}],"abstract":[{"type":"text","text":"Protocol for a monoid algebra, allowing monoidal composition. It’s a "},{"type":"codeVoice","code":"Semigroup"},{"type":"text","text":" with identity element, element which,"},{"type":"text","text":" "},{"type":"text","text":"when combined to any other element, will keep the other elemenet unchanged, regardless if the composition happened from"},{"type":"text","text":" "},{"type":"text","text":"the left or from the right, for example: "},{"type":"codeVoice","code":"a <> identity = identity <> a = a"},{"type":"text","text":", for any "},{"type":"codeVoice","code":"a"},{"type":"text","text":" in "},{"type":"codeVoice","code":"A"},{"type":"text","text":"."}],"identifier":"doc:\/\/SwiftRex\/documentation\/SwiftRex\/Monoid","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"Monoid"}],"url":"\/documentation\/swiftrex\/monoid"},"doc://SwiftRex/documentation/SwiftRex":{"role":"collection","title":"SwiftRex","abstract":[],"identifier":"doc:\/\/SwiftRex\/documentation\/SwiftRex","kind":"symbol","type":"topic","url":"\/documentation\/swiftrex"},"doc://SwiftRex/documentation/SwiftRex/Semigroup":{"role":"symbol","title":"Semigroup","fragments":[{"kind":"keyword","text":"protocol"},{"kind":"text","text":" "},{"kind":"identifier","text":"Semigroup"}],"abstract":[{"type":"text","text":"Protocol for a semigroup, any algebraic structure that allows two of its elements to be combined into one,"},{"type":"text","text":" "},{"type":"codeVoice","code":"(A, A) -> A"},{"type":"text","text":", for any of its elements and keeping associativity property for all the cases, for example:"},{"type":"text","text":" "},{"type":"codeVoice","code":"(a1 <> a2) <> a3 = a1 <> (a2 <> a3)"},{"type":"text","text":" for any "},{"type":"codeVoice","code":"a"},{"type":"text","text":"s in "},{"type":"codeVoice","code":"A"},{"type":"text","text":"."}],"identifier":"doc:\/\/SwiftRex\/documentation\/SwiftRex\/Semigroup","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"Semigroup"}],"url":"\/documentation\/swiftrex\/semigroup"}}}