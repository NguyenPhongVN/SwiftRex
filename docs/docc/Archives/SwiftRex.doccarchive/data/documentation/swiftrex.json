{"variants":[{"paths":["\/documentation\/swiftrex"],"traits":[{"interfaceLanguage":"swift"}]}],"schemaVersion":{"major":0,"minor":1,"patch":0},"sections":[],"identifier":{"url":"doc:\/\/SwiftRex\/documentation\/SwiftRex","interfaceLanguage":"swift"},"abstract":[{"type":"text","text":""}],"kind":"symbol","metadata":{"roleHeading":"Framework","externalID":"SwiftRex","title":"SwiftRex","symbolKind":"module","role":"collection","modules":[{"name":"SwiftRex"}]},"hierarchy":{"paths":[[]]},"topicSections":[{"title":"Classes","identifiers":["doc:\/\/SwiftRex\/documentation\/SwiftRex\/ReduxPipelineWrapper","doc:\/\/SwiftRex\/documentation\/SwiftRex\/ReduxStoreBase"]},{"title":"Protocols","identifiers":["doc:\/\/SwiftRex\/documentation\/SwiftRex\/ActionHandler","doc:\/\/SwiftRex\/documentation\/SwiftRex\/Middleware","doc:\/\/SwiftRex\/documentation\/SwiftRex\/MiddlewareProtocol","doc:\/\/SwiftRex\/documentation\/SwiftRex\/MiddlewareReaderProtocol","doc:\/\/SwiftRex\/documentation\/SwiftRex\/Monoid","doc:\/\/SwiftRex\/documentation\/SwiftRex\/ReduxStoreProtocol","doc:\/\/SwiftRex\/documentation\/SwiftRex\/Semigroup","doc:\/\/SwiftRex\/documentation\/SwiftRex\/StateProvider","doc:\/\/SwiftRex\/documentation\/SwiftRex\/StoreType","doc:\/\/SwiftRex\/documentation\/SwiftRex\/SubscriptionCollection","doc:\/\/SwiftRex\/documentation\/SwiftRex\/SubscriptionType"]},{"title":"Structures","identifiers":["doc:\/\/SwiftRex\/documentation\/SwiftRex\/ASAPScheduler","doc:\/\/SwiftRex\/documentation\/SwiftRex\/ActionSource","doc:\/\/SwiftRex\/documentation\/SwiftRex\/AfterReducer","doc:\/\/SwiftRex\/documentation\/SwiftRex\/AnyActionHandler","doc:\/\/SwiftRex\/documentation\/SwiftRex\/AnyMiddleware","doc:\/\/SwiftRex\/documentation\/SwiftRex\/AnyStateProvider","doc:\/\/SwiftRex\/documentation\/SwiftRex\/AnyStoreType","doc:\/\/SwiftRex\/documentation\/SwiftRex\/ComposedMiddleware","doc:\/\/SwiftRex\/documentation\/SwiftRex\/DispatchedAction","doc:\/\/SwiftRex\/documentation\/SwiftRex\/ElementIDAction","doc:\/\/SwiftRex\/documentation\/SwiftRex\/ElementIndexAction","doc:\/\/SwiftRex\/documentation\/SwiftRex\/IO","doc:\/\/SwiftRex\/documentation\/SwiftRex\/IdentityMiddleware","doc:\/\/SwiftRex\/documentation\/SwiftRex\/LiftMiddleware","doc:\/\/SwiftRex\/documentation\/SwiftRex\/LiftToCollectionMiddleware","doc:\/\/SwiftRex\/documentation\/SwiftRex\/MiddlewareReader","doc:\/\/SwiftRex\/documentation\/SwiftRex\/PublisherType","doc:\/\/SwiftRex\/documentation\/SwiftRex\/Reducer","doc:\/\/SwiftRex\/documentation\/SwiftRex\/ReplayLastSubjectType","doc:\/\/SwiftRex\/documentation\/SwiftRex\/SubjectType","doc:\/\/SwiftRex\/documentation\/SwiftRex\/SubscriberType"]},{"title":"Operators","identifiers":["doc:\/\/SwiftRex\/documentation\/SwiftRex\/__(_:_:)-23xz","doc:\/\/SwiftRex\/documentation\/SwiftRex\/__(_:_:)-4uag","doc:\/\/SwiftRex\/documentation\/SwiftRex\/__(_:_:)-uiwz"]},{"title":"Type Aliases","identifiers":["doc:\/\/SwiftRex\/documentation\/SwiftRex\/GetState","doc:\/\/SwiftRex\/documentation\/SwiftRex\/MutableReduceFunction","doc:\/\/SwiftRex\/documentation\/SwiftRex\/ReduceFunction","doc:\/\/SwiftRex\/documentation\/SwiftRex\/StoreProjection","doc:\/\/SwiftRex\/documentation\/SwiftRex\/UnfailablePublisherType","doc:\/\/SwiftRex\/documentation\/SwiftRex\/UnfailableReplayLastSubjectType","doc:\/\/SwiftRex\/documentation\/SwiftRex\/UnfailableSubject","doc:\/\/SwiftRex\/documentation\/SwiftRex\/UnfailableSubscriberType"]},{"title":"Enumerations","identifiers":["doc:\/\/SwiftRex\/documentation\/SwiftRex\/ShouldEmitValue"]}],"references":{"doc://SwiftRex/documentation/SwiftRex/StoreProjection":{"role":"symbol","title":"StoreProjection","fragments":[{"kind":"keyword","text":"typealias"},{"kind":"text","text":" "},{"kind":"identifier","text":"StoreProjection"}],"abstract":[{"type":"text","text":"An app should have a single real Store, holding a single source-of-truth. However, we can “derive” this store to small subsets, called store"},{"type":"text","text":" "},{"type":"text","text":"projections, that will handle either a smaller part of the state or action tree, or even a completely different type of actions and states as"},{"type":"text","text":" "},{"type":"text","text":"long as we can map back-and-forth to the original store types. It won’t store anything, only project the original store. For example, a View can"},{"type":"text","text":" "},{"type":"text","text":"define a completely custom View State and View Action, and we can create a "},{"type":"reference","isActive":true,"identifier":"doc:\/\/SwiftRex\/documentation\/SwiftRex\/StoreProjection"},{"type":"text","text":" that works on these types, as long as it’s backed"},{"type":"text","text":" "},{"type":"text","text":"by a real store which State and Action types can be mapped somehow to the View State and View Action types. The Store Projection will take care"},{"type":"text","text":" "},{"type":"text","text":"of translating these entities."}],"identifier":"doc:\/\/SwiftRex\/documentation\/SwiftRex\/StoreProjection","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"StoreProjection"}],"url":"\/documentation\/swiftrex\/storeprojection"},"doc://SwiftRex/documentation/SwiftRex/__(_:_:)-23xz":{"role":"symbol","title":"<>(_:_:)","fragments":[{"kind":"keyword","text":"func"},{"kind":"text","text":" "},{"kind":"identifier","text":"<>"},{"kind":"text","text":" "},{"kind":"text","text":"("},{"kind":"typeIdentifier","text":"AfterReducer","preciseIdentifier":"s:8SwiftRex12AfterReducerV"},{"kind":"text","text":", "},{"kind":"typeIdentifier","text":"AfterReducer","preciseIdentifier":"s:8SwiftRex12AfterReducerV"},{"kind":"text","text":") -> "},{"kind":"typeIdentifier","text":"AfterReducer","preciseIdentifier":"s:8SwiftRex12AfterReducerV"}],"abstract":[{"type":"text","text":"The combination between two "},{"type":"codeVoice","code":"AfterReducer"},{"type":"text","text":" instances occur in reverse order so the first middleware will have its “after reducer” closure executed"},{"type":"text","text":" "},{"type":"text","text":"last. This composition can be achieved by using the operator "},{"type":"codeVoice","code":"<>"},{"type":"text","text":"."}],"identifier":"doc:\/\/SwiftRex\/documentation\/SwiftRex\/__(_:_:)-23xz","kind":"symbol","type":"topic","deprecated":true,"url":"\/documentation\/swiftrex\/__(_:_:)-23xz"},"doc://SwiftRex/documentation/SwiftRex/LiftToCollectionMiddleware":{"role":"symbol","title":"LiftToCollectionMiddleware","fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"LiftToCollectionMiddleware"}],"abstract":[{"type":"text","text":"This is a container that lifts a sub-state middleware to a global state middleware."}],"identifier":"doc:\/\/SwiftRex\/documentation\/SwiftRex\/LiftToCollectionMiddleware","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"LiftToCollectionMiddleware"}],"url":"\/documentation\/swiftrex\/lifttocollectionmiddleware"},"doc://SwiftRex/documentation/SwiftRex/StoreType":{"role":"symbol","title":"StoreType","fragments":[{"kind":"keyword","text":"protocol"},{"kind":"text","text":" "},{"kind":"identifier","text":"StoreType"}],"abstract":[{"type":"text","text":"A protocol that defines the two expected roles of a “Store”: receive\/distribute actions ("},{"type":"reference","isActive":true,"identifier":"doc:\/\/SwiftRex\/documentation\/SwiftRex\/ActionHandler"},{"type":"text","text":"); and publish changes of the the"},{"type":"text","text":" "},{"type":"text","text":"current app state ("},{"type":"reference","isActive":true,"identifier":"doc:\/\/SwiftRex\/documentation\/SwiftRex\/StateProvider"},{"type":"text","text":") to possible subscribers. It can be a real store (such as "},{"type":"reference","isActive":true,"identifier":"doc:\/\/SwiftRex\/documentation\/SwiftRex\/ReduxStoreBase"},{"type":"text","text":") or just a “proxy” that acts on"},{"type":"text","text":" "},{"type":"text","text":"behalf of a real store, for example, in the case of "},{"type":"reference","isActive":true,"identifier":"doc:\/\/SwiftRex\/documentation\/SwiftRex\/StoreProjection"},{"type":"text","text":"."}],"identifier":"doc:\/\/SwiftRex\/documentation\/SwiftRex\/StoreType","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"StoreType"}],"url":"\/documentation\/swiftrex\/storetype"},"doc://SwiftRex/documentation/SwiftRex/IO":{"role":"symbol","title":"IO","fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"IO"}],"abstract":[],"identifier":"doc:\/\/SwiftRex\/documentation\/SwiftRex\/IO","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"IO"}],"url":"\/documentation\/swiftrex\/io"},"doc://SwiftRex/documentation/SwiftRex/IdentityMiddleware":{"role":"symbol","title":"IdentityMiddleware","fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"IdentityMiddleware"}],"abstract":[{"type":"text","text":"The "},{"type":"codeVoice","code":"IdentityMiddleware"},{"type":"text","text":" won’t do any operation, simply bypass actions through. It’s meant to provide identity axiom"},{"type":"text","text":" "},{"type":"text","text":"to middleware type to allow its conformance to monoid algebra. It will simply forward actions to the next middleware"},{"type":"text","text":" "},{"type":"text","text":"in the chain or to the reducers. It can be useful for Unit Tests or for some compositions."}],"identifier":"doc:\/\/SwiftRex\/documentation\/SwiftRex\/IdentityMiddleware","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"IdentityMiddleware"}],"url":"\/documentation\/swiftrex\/identitymiddleware"},"doc://SwiftRex/documentation/SwiftRex/__(_:_:)-4uag":{"role":"symbol","title":"<>(_:_:)","fragments":[{"kind":"keyword","text":"func"},{"kind":"text","text":" "},{"kind":"identifier","text":"<>"},{"kind":"text","text":" "},{"kind":"text","text":"<"},{"kind":"genericParameter","text":"M1"},{"kind":"text","text":", "},{"kind":"genericParameter","text":"M2"},{"kind":"text","text":">("},{"kind":"typeIdentifier","text":"M1"},{"kind":"text","text":", "},{"kind":"typeIdentifier","text":"M2"},{"kind":"text","text":") -> "},{"kind":"typeIdentifier","text":"ComposedMiddleware","preciseIdentifier":"s:8SwiftRex18ComposedMiddlewareV"},{"kind":"text","text":"<"},{"kind":"typeIdentifier","text":"M1"},{"kind":"text","text":"."},{"kind":"typeIdentifier","text":"InputActionType"},{"kind":"text","text":", "},{"kind":"typeIdentifier","text":"M1"},{"kind":"text","text":"."},{"kind":"typeIdentifier","text":"OutputActionType"},{"kind":"text","text":", "},{"kind":"typeIdentifier","text":"M1"},{"kind":"text","text":"."},{"kind":"typeIdentifier","text":"StateType"},{"kind":"text","text":">"}],"abstract":[{"type":"text","text":"Initializes a "},{"type":"codeVoice","code":"ComposedMiddleware"},{"type":"text","text":" from the "},{"type":"codeVoice","code":"lhs"},{"type":"text","text":" and "},{"type":"codeVoice","code":"rhs"},{"type":"text","text":" middlewares parameters, or appends to the "},{"type":"codeVoice","code":"lhs"},{"type":"text","text":" if it is already a "},{"type":"codeVoice","code":"ComposedMiddleware"},{"type":"text","text":", as shown below:"}],"identifier":"doc:\/\/SwiftRex\/documentation\/SwiftRex\/__(_:_:)-4uag","kind":"symbol","type":"topic","url":"\/documentation\/swiftrex\/__(_:_:)-4uag"},"doc://SwiftRex/documentation/SwiftRex/UnfailableSubject":{"role":"symbol","title":"UnfailableSubject","fragments":[{"kind":"keyword","text":"typealias"},{"kind":"text","text":" "},{"kind":"identifier","text":"UnfailableSubject"}],"abstract":[{"type":"text","text":"Abstraction over passthrough subject types ("},{"type":"codeVoice","code":"PassthroughSubject"},{"type":"text","text":", "},{"type":"codeVoice","code":"PublishSubject"},{"type":"text","text":", "},{"type":"codeVoice","code":"Signal"},{"type":"text","text":") from reactive frameworks."},{"type":"text","text":" "},{"type":"text","text":"For this specific case, the failure\/error is "},{"type":"codeVoice","code":"Never"},{"type":"text","text":", meaning that this subject can’t emit error."},{"type":"text","text":" "},{"type":"text","text":"This abstraction uses concept similar to type-erasure or protocol witness pattern, wrapping the behaviour of concrete implementations and"},{"type":"text","text":" "},{"type":"text","text":"delegating to them once the wrapper funcions are called."}],"identifier":"doc:\/\/SwiftRex\/documentation\/SwiftRex\/UnfailableSubject","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"UnfailableSubject"}],"url":"\/documentation\/swiftrex\/unfailablesubject"},"doc://SwiftRex/documentation/SwiftRex/ReduxStoreProtocol":{"role":"symbol","title":"ReduxStoreProtocol","fragments":[{"kind":"keyword","text":"protocol"},{"kind":"text","text":" "},{"kind":"identifier","text":"ReduxStoreProtocol"}],"abstract":[],"identifier":"doc:\/\/SwiftRex\/documentation\/SwiftRex\/ReduxStoreProtocol","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"ReduxStoreProtocol"}],"url":"\/documentation\/swiftrex\/reduxstoreprotocol"},"doc://SwiftRex/documentation/SwiftRex/UnfailableReplayLastSubjectType":{"role":"symbol","title":"UnfailableReplayLastSubjectType","fragments":[{"kind":"keyword","text":"typealias"},{"kind":"text","text":" "},{"kind":"identifier","text":"UnfailableReplayLastSubjectType"}],"abstract":[{"type":"text","text":"Abstraction over subject types able to keep the last object ("},{"type":"codeVoice","code":"CurrentValueSubject"},{"type":"text","text":", "},{"type":"codeVoice","code":"BehaviorSubject"},{"type":"text","text":", "},{"type":"codeVoice","code":"MutableProperty"},{"type":"text","text":", "},{"type":"codeVoice","code":"Variable"},{"type":"text","text":") from"},{"type":"text","text":" "},{"type":"text","text":"reactive frameworks."},{"type":"text","text":" "},{"type":"text","text":"For this specific case, the failure\/error is "},{"type":"codeVoice","code":"Never"},{"type":"text","text":", meaning that this subject can’t emit error."},{"type":"text","text":" "},{"type":"text","text":"This abstraction uses concept similar to type-erasure or protocol witness pattern, wrapping the behaviour of concrete implementations and"},{"type":"text","text":" "},{"type":"text","text":"delegating to them once the wrapper funcions are called."}],"identifier":"doc:\/\/SwiftRex\/documentation\/SwiftRex\/UnfailableReplayLastSubjectType","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"UnfailableReplayLastSubjectType"}],"url":"\/documentation\/swiftrex\/unfailablereplaylastsubjecttype"},"doc://SwiftRex/documentation/SwiftRex/SubscriptionType":{"role":"symbol","title":"SubscriptionType","fragments":[{"kind":"keyword","text":"protocol"},{"kind":"text","text":" "},{"kind":"identifier","text":"SubscriptionType"}],"abstract":[{"type":"text","text":"Abstraction over subscription types from reactive frameworks."},{"type":"text","text":" "},{"type":"text","text":"This abstraction uses concept similar to type-erasure or protocol witness pattern, wrapping the behaviour of concrete implementations and"},{"type":"text","text":" "},{"type":"text","text":"delegating to them once the wrapper funcions are called."}],"identifier":"doc:\/\/SwiftRex\/documentation\/SwiftRex\/SubscriptionType","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"SubscriptionType"}],"url":"\/documentation\/swiftrex\/subscriptiontype"},"doc://SwiftRex/documentation/SwiftRex/SubscriptionCollection":{"role":"symbol","title":"SubscriptionCollection","fragments":[{"kind":"keyword","text":"protocol"},{"kind":"text","text":" "},{"kind":"identifier","text":"SubscriptionCollection"}],"abstract":[{"type":"text","text":"Abstraction over subscription collection ("},{"type":"codeVoice","code":"DisposeBag"},{"type":"text","text":" or "},{"type":"codeVoice","code":"Set<AnyCancellable"},{"type":"text","text":" depending on your chosen reactive framework), useful for keeping"},{"type":"text","text":" "},{"type":"text","text":"subscriptions alive while the parent class is alive, binding the lifecycle of subscriptions to the lifecycle of views, view controllers or"},{"type":"text","text":" "},{"type":"text","text":"presenters. Subscriptions added to a subscription collection will be cancelled\/disposed automatically once the collection gets deallocated,"},{"type":"text","text":" "},{"type":"text","text":"stopping any pending operation and cleaning up the resources."},{"type":"text","text":" "},{"type":"text","text":"This abstraction uses concept similar to type-erasure or protocol witness pattern, wrapping the behaviour of concrete implementations and"},{"type":"text","text":" "},{"type":"text","text":"delegating to them once the wrapper funcions are called."}],"identifier":"doc:\/\/SwiftRex\/documentation\/SwiftRex\/SubscriptionCollection","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"SubscriptionCollection"}],"url":"\/documentation\/swiftrex\/subscriptioncollection"},"doc://SwiftRex/documentation/SwiftRex/AnyActionHandler":{"role":"symbol","title":"AnyActionHandler","fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"AnyActionHandler"}],"abstract":[{"type":"codeVoice","code":"ActionHandler"},{"type":"text","text":" defines a protocol for entities able to handle actions - defined by the associated type "},{"type":"codeVoice","code":"ActionType"},{"type":"text","text":" "},{"type":"text","text":"and "},{"type":"codeVoice","code":"AnyActionHandler"},{"type":"text","text":" erases this protocol to a generic struct type."}],"identifier":"doc:\/\/SwiftRex\/documentation\/SwiftRex\/AnyActionHandler","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"AnyActionHandler"}],"url":"\/documentation\/swiftrex\/anyactionhandler"},"doc://SwiftRex/documentation/SwiftRex/__(_:_:)-uiwz":{"role":"symbol","title":"<>(_:_:)","fragments":[{"kind":"keyword","text":"func"},{"kind":"text","text":" "},{"kind":"identifier","text":"<>"},{"kind":"text","text":" "},{"kind":"text","text":"<"},{"kind":"genericParameter","text":"OutputActionType"},{"kind":"text","text":">("},{"kind":"typeIdentifier","text":"IO","preciseIdentifier":"s:8SwiftRex2IOV"},{"kind":"text","text":"<"},{"kind":"typeIdentifier","text":"OutputActionType"},{"kind":"text","text":">, "},{"kind":"typeIdentifier","text":"IO","preciseIdentifier":"s:8SwiftRex2IOV"},{"kind":"text","text":"<"},{"kind":"typeIdentifier","text":"OutputActionType"},{"kind":"text","text":">) -> "},{"kind":"typeIdentifier","text":"IO","preciseIdentifier":"s:8SwiftRex2IOV"},{"kind":"text","text":"<"},{"kind":"typeIdentifier","text":"OutputActionType"},{"kind":"text","text":">"}],"abstract":[],"identifier":"doc:\/\/SwiftRex\/documentation\/SwiftRex\/__(_:_:)-uiwz","kind":"symbol","type":"topic","url":"\/documentation\/swiftrex\/__(_:_:)-uiwz"},"doc://SwiftRex/documentation/SwiftRex/MiddlewareProtocol":{"role":"symbol","title":"MiddlewareProtocol","fragments":[{"kind":"keyword","text":"protocol"},{"kind":"text","text":" "},{"kind":"identifier","text":"MiddlewareProtocol"}],"abstract":[{"type":"reference","isActive":true,"identifier":"doc:\/\/SwiftRex\/documentation\/SwiftRex\/MiddlewareProtocol"},{"type":"text","text":" is a plugin, or a composition of several plugins, that are assigned to the app global "},{"type":"reference","isActive":true,"identifier":"doc:\/\/SwiftRex\/documentation\/SwiftRex\/StoreType"},{"type":"text","text":" pipeline in order to"},{"type":"text","text":" "},{"type":"text","text":"handle each action received ("},{"type":"reference","isActive":true,"identifier":"doc:\/\/SwiftRex\/documentation\/SwiftRex\/MiddlewareProtocol\/InputActionType"},{"type":"text","text":"), to execute side-effects in response, and eventually dispatch more actions"},{"type":"text","text":" "},{"type":"text","text":"("},{"type":"reference","isActive":true,"identifier":"doc:\/\/SwiftRex\/documentation\/SwiftRex\/MiddlewareProtocol\/OutputActionType"},{"type":"text","text":") in the process. It can also access the most up-to-date "},{"type":"reference","isActive":true,"identifier":"doc:\/\/SwiftRex\/documentation\/SwiftRex\/MiddlewareProtocol\/StateType"},{"type":"text","text":" while handling an incoming action."}],"identifier":"doc:\/\/SwiftRex\/documentation\/SwiftRex\/MiddlewareProtocol","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"MiddlewareProtocol"}],"url":"\/documentation\/swiftrex\/middlewareprotocol"},"doc://SwiftRex/documentation/SwiftRex/Semigroup":{"role":"symbol","title":"Semigroup","fragments":[{"kind":"keyword","text":"protocol"},{"kind":"text","text":" "},{"kind":"identifier","text":"Semigroup"}],"abstract":[{"type":"text","text":"Protocol for a semigroup, any algebraic structure that allows two of its elements to be combined into one,"},{"type":"text","text":" "},{"type":"codeVoice","code":"(A, A) -> A"},{"type":"text","text":", for any of its elements and keeping associativity property for all the cases, for example:"},{"type":"text","text":" "},{"type":"codeVoice","code":"(a1 <> a2) <> a3 = a1 <> (a2 <> a3)"},{"type":"text","text":" for any "},{"type":"codeVoice","code":"a"},{"type":"text","text":"s in "},{"type":"codeVoice","code":"A"},{"type":"text","text":"."}],"identifier":"doc:\/\/SwiftRex\/documentation\/SwiftRex\/Semigroup","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"Semigroup"}],"url":"\/documentation\/swiftrex\/semigroup"},"doc://SwiftRex/documentation/SwiftRex/Middleware":{"deprecated":true,"role":"symbol","title":"Middleware","fragments":[{"kind":"keyword","text":"protocol"},{"kind":"text","text":" "},{"kind":"identifier","text":"Middleware"}],"abstract":[{"type":"text","text":"⛓ "},{"type":"codeVoice","code":"Middleware"},{"type":"text","text":" is a plugin, or a composition of several plugins, that are assigned to the "},{"type":"codeVoice","code":"ReduxStoreProtocol"},{"type":"text","text":" pipeline in order to handle each"},{"type":"text","text":" "},{"type":"text","text":"action received ("},{"type":"codeVoice","code":"InputActionType"},{"type":"text","text":"), to execute side-effects in response, and eventually dispatch more actions ("},{"type":"codeVoice","code":"OutputActionType"},{"type":"text","text":") in the process."},{"type":"text","text":" "},{"type":"text","text":"This happens before the "},{"type":"codeVoice","code":"Reducer"},{"type":"text","text":" to do its job."}],"identifier":"doc:\/\/SwiftRex\/documentation\/SwiftRex\/Middleware","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"Middleware"}],"url":"\/documentation\/swiftrex\/middleware"},"doc://SwiftRex/documentation/SwiftRex/ActionHandler":{"role":"symbol","title":"ActionHandler","fragments":[{"kind":"keyword","text":"protocol"},{"kind":"text","text":" "},{"kind":"identifier","text":"ActionHandler"}],"abstract":[{"type":"codeVoice","code":"ActionHandler"},{"type":"text","text":" defines a protocol for entities able to handle actions - defined by the associated type "},{"type":"codeVoice","code":"ActionType"},{"type":"text","text":"."}],"identifier":"doc:\/\/SwiftRex\/documentation\/SwiftRex\/ActionHandler","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"ActionHandler"}],"url":"\/documentation\/swiftrex\/actionhandler"},"doc://SwiftRex/documentation/SwiftRex/DispatchedAction":{"role":"symbol","title":"DispatchedAction","fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"DispatchedAction"}],"abstract":[{"type":"text","text":"Wraps an action and the information about its dispatcher. It can be used when reactive pipelines want to enforce that the result is an action"},{"type":"text","text":" "},{"type":"text","text":"while keeping track about the source of that action. For example, certain RxSwift, Combine or ReactiveSwift pipeline want to send actions to the"},{"type":"text","text":" "},{"type":"text","text":"store and because ActionHandler has a function "},{"type":"codeVoice","code":"dispatch(_ action: ActionType, from dispatcher: ActionSource)"},{"type":"text","text":", that pipeline should output a"},{"type":"text","text":" "},{"type":"codeVoice","code":"DispatchedAction<Action>"},{"type":"text","text":" to fulfil everything needed by the ActionHandler to feed that action into the store."}],"identifier":"doc:\/\/SwiftRex\/documentation\/SwiftRex\/DispatchedAction","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"DispatchedAction"}],"url":"\/documentation\/swiftrex\/dispatchedaction"},"doc://SwiftRex/documentation/SwiftRex/MiddlewareProtocol/OutputActionType":{"role":"symbol","title":"OutputActionType","fragments":[{"kind":"keyword","text":"associatedtype"},{"kind":"text","text":" "},{"kind":"identifier","text":"OutputActionType"}],"abstract":[{"type":"text","text":"The Action type that this "},{"type":"reference","isActive":true,"identifier":"doc:\/\/SwiftRex\/documentation\/SwiftRex\/MiddlewareProtocol"},{"type":"text","text":" will eventually trigger back to the store in response of side-effects. This can be the same"},{"type":"text","text":" "},{"type":"text","text":"as "},{"type":"reference","isActive":true,"identifier":"doc:\/\/SwiftRex\/documentation\/SwiftRex\/MiddlewareProtocol\/InputActionType"},{"type":"text","text":" or different, in case you want to separate your enum in requests and responses."}],"identifier":"doc:\/\/SwiftRex\/documentation\/SwiftRex\/MiddlewareProtocol\/OutputActionType","kind":"symbol","required":true,"type":"topic","url":"\/documentation\/swiftrex\/middlewareprotocol\/outputactiontype"},"doc://SwiftRex/documentation/SwiftRex/Reducer":{"role":"symbol","title":"Reducer","fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"Reducer"}],"abstract":[{"type":"codeVoice","code":"Reducer"},{"type":"text","text":" is a pure function wrapped in a monoid container, that takes an action and the current state to calculate the new state."}],"identifier":"doc:\/\/SwiftRex\/documentation\/SwiftRex\/Reducer","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"Reducer"}],"url":"\/documentation\/swiftrex\/reducer"},"doc://SwiftRex/documentation/SwiftRex/GetState":{"role":"symbol","title":"GetState","fragments":[{"kind":"keyword","text":"typealias"},{"kind":"text","text":" "},{"kind":"identifier","text":"GetState"}],"abstract":[{"type":"text","text":"Zero-argument function that returns the current state. "},{"type":"text","text":" "},{"type":"codeVoice","code":"() -> StateType"}],"identifier":"doc:\/\/SwiftRex\/documentation\/SwiftRex\/GetState","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"GetState"}],"url":"\/documentation\/swiftrex\/getstate"},"doc://SwiftRex/documentation/SwiftRex/ComposedMiddleware":{"role":"symbol","title":"ComposedMiddleware","fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"ComposedMiddleware"}],"abstract":[{"type":"text","text":"The "},{"type":"codeVoice","code":"ComposedMiddleware"},{"type":"text","text":" is a container of inner middlewares that are chained together in the order as they were composed. Whenever an "},{"type":"codeVoice","code":"EventProtocol"},{"type":"text","text":" or an "},{"type":"codeVoice","code":"ActionProtocol"},{"type":"text","text":" arrives to be handled by this "},{"type":"codeVoice","code":"ComposedMiddleware"},{"type":"text","text":", it will delegate to its internal chain of middlewares."}],"identifier":"doc:\/\/SwiftRex\/documentation\/SwiftRex\/ComposedMiddleware","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"ComposedMiddleware"}],"url":"\/documentation\/swiftrex\/composedmiddleware"},"doc://SwiftRex/documentation/SwiftRex/ReplayLastSubjectType":{"role":"symbol","title":"ReplayLastSubjectType","fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"ReplayLastSubjectType"}],"abstract":[{"type":"text","text":"Abstraction over subject types able to keep the last object ("},{"type":"codeVoice","code":"CurrentValueSubject"},{"type":"text","text":", "},{"type":"codeVoice","code":"BehaviorSubject"},{"type":"text","text":", "},{"type":"codeVoice","code":"MutableProperty"},{"type":"text","text":", "},{"type":"codeVoice","code":"Variable"},{"type":"text","text":") from"},{"type":"text","text":" "},{"type":"text","text":"reactive frameworks."},{"type":"text","text":" "},{"type":"text","text":"This abstraction uses concept similar to type-erasure or protocol witness pattern, wrapping the behaviour of concrete implementations and"},{"type":"text","text":" "},{"type":"text","text":"delegating to them once the wrapper funcions are called."}],"identifier":"doc:\/\/SwiftRex\/documentation\/SwiftRex\/ReplayLastSubjectType","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"ReplayLastSubjectType"}],"url":"\/documentation\/swiftrex\/replaylastsubjecttype"},"doc://SwiftRex/documentation/SwiftRex/AfterReducer":{"deprecated":true,"role":"symbol","title":"AfterReducer","fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"AfterReducer"}],"abstract":[{"type":"text","text":"Wraps a closure that will be called after the Reducer pipeline has changed the state with the current action."},{"type":"text","text":" "},{"type":"text","text":"With this structure, a middleware can schedule some callback to be executed with the new state, and evidently access this state to check what’s"},{"type":"text","text":" "},{"type":"text","text":"different. This can be very useful for Middlewares that perform logging, monitoring or telemetry, so you can check the state before and after"},{"type":"text","text":" "},{"type":"text","text":"reducers’ execution, or how much time it took for the whole chain to be called (in case this middleware is the first in the chain, of course)."},{"type":"text","text":" "},{"type":"codeVoice","code":"AfterReducer"},{"type":"text","text":" is a monoid, that means it can be combined with another "},{"type":"codeVoice","code":"AfterReducer"},{"type":"text","text":" to form a new one (that executes both operations in the"},{"type":"text","text":" "},{"type":"text","text":"reverse order) and an identity instance, that when combined with any other "},{"type":"codeVoice","code":"AfterReducer"},{"type":"text","text":" changes nothing in the result, acting as a neutral"},{"type":"text","text":" "},{"type":"text","text":"element in composition. The identity of an "},{"type":"codeVoice","code":"AfterReducer"},{"type":"text","text":" is the static instance "},{"type":"codeVoice","code":"doNothing()"},{"type":"text","text":", that contains an empty closure for no-op."},{"type":"text","text":" "},{"type":"text","text":"The combination between two "},{"type":"codeVoice","code":"AfterReducer"},{"type":"text","text":" instances occur in reverse order so the first middleware will have its “after reducer” closure executed"},{"type":"text","text":" "},{"type":"text","text":"last. This composition can be achieved by using the operator "},{"type":"codeVoice","code":"<>"}],"identifier":"doc:\/\/SwiftRex\/documentation\/SwiftRex\/AfterReducer","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"AfterReducer"}],"url":"\/documentation\/swiftrex\/afterreducer"},"doc://SwiftRex/documentation/SwiftRex/AnyStateProvider":{"role":"symbol","title":"AnyStateProvider","fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"AnyStateProvider"}],"abstract":[{"type":"codeVoice","code":"AnyStateProvider"},{"type":"text","text":" erases the protocol "},{"type":"codeVoice","code":"StateProvider"},{"type":"text","text":", which defines a entities able to offer state publishers (Combine Publisher, RxSwift"},{"type":"text","text":" "},{"type":"text","text":"Observable, ReactiveSwift SignalProducer) of certain "},{"type":"codeVoice","code":"StateType"},{"type":"text","text":", so everybody can observe the global state changes through this container. Usually"},{"type":"text","text":" "},{"type":"text","text":"a "},{"type":"codeVoice","code":"Store"},{"type":"text","text":" will implement that, but it can also be a "},{"type":"codeVoice","code":"StoreProjection"},{"type":"text","text":" with a state that is derived from the global source-of-truth."}],"identifier":"doc:\/\/SwiftRex\/documentation\/SwiftRex\/AnyStateProvider","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"AnyStateProvider"}],"url":"\/documentation\/swiftrex\/anystateprovider"},"doc://SwiftRex/documentation/SwiftRex/PublisherType":{"role":"symbol","title":"PublisherType","fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"PublisherType"}],"abstract":[{"type":"text","text":"Abstraction over publisher\/observable\/signal producer types from reactive frameworks."},{"type":"text","text":" "},{"type":"text","text":"This abstraction uses concept similar to type-erasure or protocol witness pattern, wrapping the behaviour of concrete implementations and"},{"type":"text","text":" "},{"type":"text","text":"delegating to them once the wrapper funcions are called."}],"identifier":"doc:\/\/SwiftRex\/documentation\/SwiftRex\/PublisherType","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"PublisherType"}],"url":"\/documentation\/swiftrex\/publishertype"},"doc://SwiftRex/documentation/SwiftRex/AnyMiddleware":{"role":"symbol","title":"AnyMiddleware","fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"AnyMiddleware"}],"abstract":[{"type":"text","text":"Erases the protocol "},{"type":"codeVoice","code":"Middleware"},{"type":"text","text":". Please check its documentation for more information."}],"identifier":"doc:\/\/SwiftRex\/documentation\/SwiftRex\/AnyMiddleware","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"AnyMiddleware"}],"url":"\/documentation\/swiftrex\/anymiddleware"},"doc://SwiftRex/documentation/SwiftRex/ShouldEmitValue":{"role":"symbol","title":"ShouldEmitValue","fragments":[{"kind":"keyword","text":"enum"},{"kind":"text","text":" "},{"kind":"identifier","text":"ShouldEmitValue"}],"abstract":[{"type":"text","text":"A predicate that determines if a state change should notify subscribers or not, by comparing previous and new states and returning a Bool true in"},{"type":"text","text":" "},{"type":"text","text":"case it should emit it, or false in case it should not emit it."},{"type":"text","text":" "},{"type":"text","text":"It comes with some standard options like "},{"type":"codeVoice","code":".always"},{"type":"text","text":", "},{"type":"codeVoice","code":".never"},{"type":"text","text":", "},{"type":"codeVoice","code":".when(old, new) -> Bool"},{"type":"text","text":" and, for "},{"type":"codeVoice","code":"Equatable"},{"type":"text","text":" structures, "},{"type":"codeVoice","code":".whenDifferent"},{"type":"text","text":"."}],"identifier":"doc:\/\/SwiftRex\/documentation\/SwiftRex\/ShouldEmitValue","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"ShouldEmitValue"}],"url":"\/documentation\/swiftrex\/shouldemitvalue"},"doc://SwiftRex/documentation/SwiftRex/StateProvider":{"role":"symbol","title":"StateProvider","fragments":[{"kind":"keyword","text":"protocol"},{"kind":"text","text":" "},{"kind":"identifier","text":"StateProvider"}],"abstract":[{"type":"codeVoice","code":"StateProvider"},{"type":"text","text":" defines a protocol for entities able to offer state publishers (Combine Publisher, RxSwift Observable,"},{"type":"text","text":" "},{"type":"text","text":"ReactiveSwift SignalProducer) of certain "},{"type":"codeVoice","code":"StateType"},{"type":"text","text":", so everybody can observe the global state changes through this"},{"type":"text","text":" "},{"type":"text","text":"container. Usually a "},{"type":"codeVoice","code":"Store"},{"type":"text","text":" will implement that, but it can also be a "},{"type":"codeVoice","code":"StoreProjection"},{"type":"text","text":" with a state that is derived from"},{"type":"text","text":" "},{"type":"text","text":"the global source-of-truth."}],"identifier":"doc:\/\/SwiftRex\/documentation\/SwiftRex\/StateProvider","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"StateProvider"}],"url":"\/documentation\/swiftrex\/stateprovider"},"doc://SwiftRex/documentation/SwiftRex/ActionSource":{"role":"symbol","title":"ActionSource","fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"ActionSource"}],"abstract":[{"type":"text","text":"Representation of the entity responsible for creating and dispatching the action, including information useful for logging, debugging, analytics"},{"type":"text","text":" "},{"type":"text","text":"or monitoring. The action source will be implicitly created when "},{"type":"codeVoice","code":"ActionHandler.dispatch"},{"type":"text","text":" is called from a middleware, view or presenter, and"},{"type":"text","text":" "},{"type":"text","text":"it will contain the file, function and line from where the dispatch function was called. Additionally you can append extra information useful"},{"type":"text","text":" "},{"type":"text","text":"for debugging, as an optional String attached to the ActionSource."}],"identifier":"doc:\/\/SwiftRex\/documentation\/SwiftRex\/ActionSource","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"ActionSource"}],"url":"\/documentation\/swiftrex\/actionsource"},"doc://SwiftRex/documentation/SwiftRex/MiddlewareReader":{"role":"symbol","title":"MiddlewareReader","fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"MiddlewareReader"}],"abstract":[{"type":"text","text":"A MiddlewareReader is a way to lazily inject dependencies into a Middleware. For example, you may want to compose multiple middlewares but from"},{"type":"text","text":" "},{"type":"text","text":"a library, and in this library you don’t have the dependencies to inject just yet, because these dependencies are only present in the main target."},{"type":"text","text":" "},{"type":"text","text":"That way, instead of creating the middlewares (which would require all the dependencies), you can wrap their initializers in a MiddlewareReader."},{"type":"text","text":" "},{"type":"text","text":"The middleware reader is not a middleware, is a a factory (in OOP terms) from "},{"type":"codeVoice","code":"(Dependencies) -> MiddlewareType"},{"type":"text","text":" (in FP approach). The benefit"},{"type":"text","text":" "},{"type":"text","text":"of wrapping the middleware initializers in a MiddlewareReader is that, for all means, MiddlewareReaders can be composed as Middlewares, can be"},{"type":"text","text":" "},{"type":"text","text":"lifted as Middlewares, but all of this without in fact creating the Middlewares."},{"type":"text","text":" "},{"type":"text","text":"Your library can then expose a single MiddlewareReader as public, and you keep all its middlewares as internal classes. From the main target you"},{"type":"text","text":" "},{"type":"text","text":"compose this MiddlewareReader with other MiddlewareReaders coming from other libraries and from the main target itself. Somewhere where you create"},{"type":"text","text":" "},{"type":"text","text":"the Store, you finally inject the dependencies at once and you materialize all your middlewares at the same time."},{"type":"text","text":" "},{"type":"text","text":"Remember that “inject then compose” is the same as “compose then inject”, but while the former needs dependencies upfront, the latter is more"},{"type":"text","text":" "},{"type":"text","text":"flexible for being lazy."},{"type":"text","text":" "},{"type":"text","text":"For those familiar with Functional Programming, this is similar to Reader Monad, but as SwiftRex recommends dependencies only on Middlewares,"},{"type":"text","text":" "},{"type":"text","text":"this Reader works specifically with Middlewares."}],"identifier":"doc:\/\/SwiftRex\/documentation\/SwiftRex\/MiddlewareReader","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"MiddlewareReader"}],"url":"\/documentation\/swiftrex\/middlewarereader"},"doc://SwiftRex/documentation/SwiftRex/ElementIDAction":{"role":"symbol","title":"ElementIDAction","fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"ElementIDAction"}],"abstract":[],"identifier":"doc:\/\/SwiftRex\/documentation\/SwiftRex\/ElementIDAction","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"ElementIDAction"}],"url":"\/documentation\/swiftrex\/elementidaction"},"doc://SwiftRex/documentation/SwiftRex/UnfailableSubscriberType":{"role":"symbol","title":"UnfailableSubscriberType","fragments":[{"kind":"keyword","text":"typealias"},{"kind":"text","text":" "},{"kind":"identifier","text":"UnfailableSubscriberType"}],"abstract":[{"type":"text","text":"Abstraction over subscriber\/observer types from reactive frameworks."},{"type":"text","text":" "},{"type":"text","text":"For this specific case, the failure\/error is "},{"type":"codeVoice","code":"Never"},{"type":"text","text":", meaning that this subscriber can only subscribe to publishers that don’t emit errors."},{"type":"text","text":" "},{"type":"text","text":"This abstraction uses concept similar to type-erasure or protocol witness pattern, wrapping the behaviour of concrete implementations and"},{"type":"text","text":" "},{"type":"text","text":"delegating to them once the wrapper funcions are called."}],"identifier":"doc:\/\/SwiftRex\/documentation\/SwiftRex\/UnfailableSubscriberType","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"UnfailableSubscriberType"}],"url":"\/documentation\/swiftrex\/unfailablesubscribertype"},"doc://SwiftRex/documentation/SwiftRex/LiftMiddleware":{"role":"symbol","title":"LiftMiddleware","fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"LiftMiddleware"}],"abstract":[{"type":"text","text":"This is a container that lifts a sub-state middleware to a global state middleware."}],"identifier":"doc:\/\/SwiftRex\/documentation\/SwiftRex\/LiftMiddleware","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"LiftMiddleware"}],"url":"\/documentation\/swiftrex\/liftmiddleware"},"doc://SwiftRex/documentation/SwiftRex/ASAPScheduler":{"role":"symbol","title":"ASAPScheduler","fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"ASAPScheduler"}],"abstract":[{"type":"text","text":"A very eager scheduler that will perform tasks in the Main Queue, immediately if possible."}],"identifier":"doc:\/\/SwiftRex\/documentation\/SwiftRex\/ASAPScheduler","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"ASAPScheduler"}],"url":"\/documentation\/swiftrex\/asapscheduler"},"doc://SwiftRex/documentation/SwiftRex/Monoid":{"role":"symbol","title":"Monoid","fragments":[{"kind":"keyword","text":"protocol"},{"kind":"text","text":" "},{"kind":"identifier","text":"Monoid"}],"abstract":[{"type":"text","text":"Protocol for a monoid algebra, allowing monoidal composition. It’s a "},{"type":"codeVoice","code":"Semigroup"},{"type":"text","text":" with identity element, element which,"},{"type":"text","text":" "},{"type":"text","text":"when combined to any other element, will keep the other elemenet unchanged, regardless if the composition happened from"},{"type":"text","text":" "},{"type":"text","text":"the left or from the right, for example: "},{"type":"codeVoice","code":"a <> identity = identity <> a = a"},{"type":"text","text":", for any "},{"type":"codeVoice","code":"a"},{"type":"text","text":" in "},{"type":"codeVoice","code":"A"},{"type":"text","text":"."}],"identifier":"doc:\/\/SwiftRex\/documentation\/SwiftRex\/Monoid","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"Monoid"}],"url":"\/documentation\/swiftrex\/monoid"},"doc://SwiftRex/documentation/SwiftRex/AnyStoreType":{"role":"symbol","title":"AnyStoreType","fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"AnyStoreType"}],"abstract":[{"type":"text","text":"Type-erasure for the protocol "},{"type":"reference","isActive":true,"identifier":"doc:\/\/SwiftRex\/documentation\/SwiftRex\/StoreType"},{"type":"text","text":"."}],"identifier":"doc:\/\/SwiftRex\/documentation\/SwiftRex\/AnyStoreType","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"AnyStoreType"}],"url":"\/documentation\/swiftrex\/anystoretype"},"doc://SwiftRex/documentation/SwiftRex/MiddlewareProtocol/StateType":{"role":"symbol","title":"StateType","fragments":[{"kind":"keyword","text":"associatedtype"},{"kind":"text","text":" "},{"kind":"identifier","text":"StateType"}],"abstract":[{"type":"text","text":"The State part that this "},{"type":"reference","isActive":true,"identifier":"doc:\/\/SwiftRex\/documentation\/SwiftRex\/MiddlewareProtocol"},{"type":"text","text":" needs to read in order to make decisions. This middleware will be able to read the most"},{"type":"text","text":" "},{"type":"text","text":"up-to-date "},{"type":"reference","isActive":true,"identifier":"doc:\/\/SwiftRex\/documentation\/SwiftRex\/MiddlewareProtocol\/StateType"},{"type":"text","text":" from the store while handling an incoming action, but it can never write or make changes to it."}],"identifier":"doc:\/\/SwiftRex\/documentation\/SwiftRex\/MiddlewareProtocol\/StateType","kind":"symbol","required":true,"type":"topic","url":"\/documentation\/swiftrex\/middlewareprotocol\/statetype"},"doc://SwiftRex/documentation/SwiftRex/MiddlewareProtocol/InputActionType":{"role":"symbol","title":"InputActionType","fragments":[{"kind":"keyword","text":"associatedtype"},{"kind":"text","text":" "},{"kind":"identifier","text":"InputActionType"}],"abstract":[{"type":"text","text":"The Action type that this "},{"type":"reference","isActive":true,"identifier":"doc:\/\/SwiftRex\/documentation\/SwiftRex\/MiddlewareProtocol"},{"type":"text","text":" knows how to handle, so the store will forward actions of this type to this middleware."}],"identifier":"doc:\/\/SwiftRex\/documentation\/SwiftRex\/MiddlewareProtocol\/InputActionType","kind":"symbol","required":true,"type":"topic","url":"\/documentation\/swiftrex\/middlewareprotocol\/inputactiontype"},"doc://SwiftRex/documentation/SwiftRex/ElementIndexAction":{"role":"symbol","title":"ElementIndexAction","fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"ElementIndexAction"}],"abstract":[],"identifier":"doc:\/\/SwiftRex\/documentation\/SwiftRex\/ElementIndexAction","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"ElementIndexAction"}],"url":"\/documentation\/swiftrex\/elementindexaction"},"doc://SwiftRex/documentation/SwiftRex/MutableReduceFunction":{"role":"symbol","title":"MutableReduceFunction","fragments":[{"kind":"keyword","text":"typealias"},{"kind":"text","text":" "},{"kind":"identifier","text":"MutableReduceFunction"}],"abstract":[{"type":"text","text":"State reducer: takes inout version of the current state and an action, computes the new state changing the provided mutable state. "},{"type":"text","text":" "},{"type":"codeVoice","code":"(ActionType, inout StateType) -> Void"}],"identifier":"doc:\/\/SwiftRex\/documentation\/SwiftRex\/MutableReduceFunction","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"MutableReduceFunction"}],"url":"\/documentation\/swiftrex\/mutablereducefunction"},"doc://SwiftRex/documentation/SwiftRex/SubscriberType":{"role":"symbol","title":"SubscriberType","fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"SubscriberType"}],"abstract":[{"type":"text","text":"Abstraction over subscriber\/observer types from reactive frameworks."},{"type":"text","text":" "},{"type":"text","text":"This abstraction uses concept similar to type-erasure or protocol witness pattern, wrapping the behaviour of concrete implementations and"},{"type":"text","text":" "},{"type":"text","text":"delegating to them once the wrapper funcions are called."}],"identifier":"doc:\/\/SwiftRex\/documentation\/SwiftRex\/SubscriberType","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"SubscriberType"}],"url":"\/documentation\/swiftrex\/subscribertype"},"doc://SwiftRex/documentation/SwiftRex/MiddlewareReaderProtocol":{"role":"symbol","title":"MiddlewareReaderProtocol","fragments":[{"kind":"keyword","text":"protocol"},{"kind":"text","text":" "},{"kind":"identifier","text":"MiddlewareReaderProtocol"}],"abstract":[{"type":"text","text":"A protocol to generalize MiddlewareReader. Unless you look for some very special behaviour, you should use MiddlewareReader directly which"},{"type":"text","text":" "},{"type":"text","text":"provides everything needed for your Middleware dependency injection."}],"identifier":"doc:\/\/SwiftRex\/documentation\/SwiftRex\/MiddlewareReaderProtocol","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"MiddlewareReaderProtocol"}],"url":"\/documentation\/swiftrex\/middlewarereaderprotocol"},"doc://SwiftRex/documentation/SwiftRex":{"role":"collection","title":"SwiftRex","abstract":[],"identifier":"doc:\/\/SwiftRex\/documentation\/SwiftRex","kind":"symbol","type":"topic","url":"\/documentation\/swiftrex"},"doc://SwiftRex/documentation/SwiftRex/ReduceFunction":{"deprecated":true,"role":"symbol","title":"ReduceFunction","fragments":[{"kind":"keyword","text":"typealias"},{"kind":"text","text":" "},{"kind":"identifier","text":"ReduceFunction"}],"abstract":[{"type":"text","text":"State reducer: takes current state and an action, computes the new state. "},{"type":"text","text":" "},{"type":"codeVoice","code":"(ActionType, StateType) -> StateType"}],"identifier":"doc:\/\/SwiftRex\/documentation\/SwiftRex\/ReduceFunction","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"ReduceFunction"}],"url":"\/documentation\/swiftrex\/reducefunction"},"doc://SwiftRex/documentation/SwiftRex/ReduxStoreBase":{"role":"symbol","title":"ReduxStoreBase","fragments":[{"kind":"keyword","text":"class"},{"kind":"text","text":" "},{"kind":"identifier","text":"ReduxStoreBase"}],"abstract":[{"type":"text","text":"🏪 "},{"type":"codeVoice","code":"ReduxStoreBase"},{"type":"text","text":" is a base class that can be used to create the main store of an app, using the redux pattern."}],"identifier":"doc:\/\/SwiftRex\/documentation\/SwiftRex\/ReduxStoreBase","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"ReduxStoreBase"}],"url":"\/documentation\/swiftrex\/reduxstorebase"},"doc://SwiftRex/documentation/SwiftRex/UnfailablePublisherType":{"role":"symbol","title":"UnfailablePublisherType","fragments":[{"kind":"keyword","text":"typealias"},{"kind":"text","text":" "},{"kind":"identifier","text":"UnfailablePublisherType"}],"abstract":[{"type":"text","text":"Abstraction over publisher\/observable\/signal producer types from reactive frameworks."},{"type":"text","text":" "},{"type":"text","text":"For this specific case, the failure\/error is "},{"type":"codeVoice","code":"Never"},{"type":"text","text":", meaning that this publisher can’t emit error."},{"type":"text","text":" "},{"type":"text","text":"This abstraction uses concept similar to type-erasure or protocol witness pattern, wrapping the behaviour of concrete implementations and"},{"type":"text","text":" "},{"type":"text","text":"delegating to them once the wrapper funcions are called."}],"identifier":"doc:\/\/SwiftRex\/documentation\/SwiftRex\/UnfailablePublisherType","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"UnfailablePublisherType"}],"url":"\/documentation\/swiftrex\/unfailablepublishertype"},"doc://SwiftRex/documentation/SwiftRex/ReduxPipelineWrapper":{"role":"symbol","title":"ReduxPipelineWrapper","fragments":[{"kind":"keyword","text":"class"},{"kind":"text","text":" "},{"kind":"identifier","text":"ReduxPipelineWrapper"}],"abstract":[],"identifier":"doc:\/\/SwiftRex\/documentation\/SwiftRex\/ReduxPipelineWrapper","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"ReduxPipelineWrapper"}],"url":"\/documentation\/swiftrex\/reduxpipelinewrapper"},"doc://SwiftRex/documentation/SwiftRex/SubjectType":{"role":"symbol","title":"SubjectType","fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"SubjectType"}],"abstract":[{"type":"text","text":"Abstraction over passthrough subject types ("},{"type":"codeVoice","code":"PassthroughSubject"},{"type":"text","text":", "},{"type":"codeVoice","code":"PublishSubject"},{"type":"text","text":", "},{"type":"codeVoice","code":"Signal"},{"type":"text","text":") from reactive frameworks."},{"type":"text","text":" "},{"type":"text","text":"This abstraction uses concept similar to type-erasure or protocol witness pattern, wrapping the behaviour of concrete implementations and"},{"type":"text","text":" "},{"type":"text","text":"delegating to them once the wrapper funcions are called."}],"identifier":"doc:\/\/SwiftRex\/documentation\/SwiftRex\/SubjectType","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"SubjectType"}],"url":"\/documentation\/swiftrex\/subjecttype"}}}